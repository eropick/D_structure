스택(stack): 아래에서 위로 쌓아두고 다시 위에서 아래로 빼는 형태의 자료구조.
컴퓨터에서 믿을 수 없을 정도로 많이 사용되는 자료구조로 주변에서도
스마트폰의 뒤로 가기를 누르면 현재 수행되는 앱이 종료되고 이전에 수행되던 앱이
다시 나타나는 구조도 스택형식으로 되어있다. 또 함수를 호출하게 되면 지역변수와
매개변수, 함수의 복귀주소등이 (운영체제의)시스템스택에 저장되어 함수가 종료되면 
운영체제에 반환한다. 

일상생활에서도 창고에 쌓여있는 상자를 생각해보자. 창고에서 새로운 상자를 쌓을 때는
제일 윗부분에 놓게된다. 상자가 필요하면 가장 윗부분부터 꺼내서 사용한다.
만약 중간부터 꺼내는 경우 상자가 붕괴될 것이다. 이러한 입출력 형태를 "후입선출"
나중에 들어온 것이 먼저 나간다는 의미를 갖는다.

따라서 입력과 출력은 스택의 최상단에서 이루어지기 때문에 스택 상단(stack top)이라고 하고
반대쪽인 하단부를 스택 하단(stack bottom)이라고 한다. 또 스택에 저장되는 것을 요소(element)라고
부른다. 스택에 요소가 하나도 없는 스택을 공백 스택(empty stack)이라고 부른다.

스택은 특히 자료의 출력순서가 입력순서의 거꾸로 되어야할 때 요긴하게 쓰인다.
예를 들면 A,B,C,D,E의 순서로 입력된 자료를 E,D,C,B,A처럼 출력할 때다.
또는 가장최근에 수행된 내역으로 돌아가는 되돌리기 기능도 있다.



스택의 ADT이다.
객체: 0개 이상의 원소를 가지는 유한 선형 리스트
연산{
    create(size): size크기의 empty stack을 생성함.
    is_full(stack) ::= 스택이 가득 차 있는지 판단.
        if(stack의 요소 수 == size) return TRUE;
        else return FALSE;
    is_empty(stack) ::= 스택이 비어있는지 판단.
        if(stack의 요소 수 == 0) return TRUE;
        else return FALSE;
    push(stack, item) ::= 스택에 특정 값을 추가함.
        if(is_full(stack)) return ERR_STACKFULL;
        else 스택의 맨 위에 값 추가.
    pop(stack) ::= 스택 맨 위에 있는 값을 제거 후 반환.
        if(is_empty(stack)) return ERR_STACKEMPTY;
        else 스택의 맨 위에 값을 제거 후 반환.
    peek(stack) ::= 스택의 가장 위에 있는 원소를 반환
        if(is_empty(stack)) return ERR_STACKEMPTY;
        else 스택의 맨 위에 있는 값 반환.
}

스택은 배열을 이용해서 구현할 수도 있고 연결리스트를 통해 구현할 수도 있다.
배열을 이용해서 구현할 경우 간단하고 성능이 우수한 반면 크기 설정되기 때문에 
크기가 제한된다는 단점이 있다. 연결리스트로 만든다면 구현이 복잡한 반면, 
크기를 필요에 따라 가변적으로 할 수 있다.
연결리스트는 나중에 학습하도록 하고 우선 배열을 이용한 스택을 만들어보자.

우선 stack top의 경우는 비어있을 경우 -1이라는 값을 갖는다. 
배열은 0부터 시작하기 때문이다.
이를 알고있다면 쉽게 배열로 구현할 수 있을 것이다. 

요소에 정수만 들어간다면 정수 배열스택, 문자가 들어간다면 문자 배열스택,
여러가지 요소들이 종합적으로 들어간다면 구조체 배열스택을 만들면 된다.

1. 전역변수와 배열,구조체를 이용한 방법
전역변수로 int top와 element stack[size] 스택배열,구조체를 생성한다.
그리고 각 스택은 함수를 통해 접근하는 방식이다. 단, 전역변수로 top과 스택을 생성하게 되면 
하나의 프로그램에 하나의 스택만 사용하게 되는 셈이다.

2. 여러개의 스택을 사용하기 위해서 객체지향의 개념을 사용하면 더 편리하지만 C의 경우는 
스택과 top을 하나의 구조체로 묶어 구조체 포인터를 함수의 매개변수로 사용해야한다.

typedef struct{
    int top;
    element stack[size];
}

다음과 같이 하나의 스택을 구현할 수 있는 멤버를 갖는 구조체를 만드는 것이다.
다만 스택의 크기는 항상 정해져있어 꽉차게된다면 스택을 줄여서 사용해야한다는 단점이 있다.

3. typedef struct{
    int top;
    int capacity
    element* stack;
}
따라서 다음과 같이 구조체 포인터로 선언한 후 동적할당을 사용하면 
스택의 크기를 미리 정해놓지 않고 스택이 꽉찰 때마다 capacity의 크기만큼 할당해서
사용할 수도 있다. 따라서 realloc()이라는 함수를 통해 메모리 공간을 다시 재할당해주는
연산과정도 필요하다. 사용방식은 realloc(이전의 할당된 메모리 포인터,사이즈)
exit()함수는 어디에서 쓰이던지 프로세스를 완전히 종료하고 파라미터에 있는 값을
반환하는 함수다. 함수 안에서 return을 쓰면 그 함수만 종료되지만 exit함수를 쓰면
프로세스 자체가 종료된다.

스택의 응용: 괄호검사
프로그래밍 언어에서는 여러개의 괄호가 사용되는데 괄호의 짝이 일치해야 맞기 때문에
오류검사를 하는 프로그램을 만드는데 스택이 사용된다. 조건은 다음과 같다.
1. 왼쪽 괄호와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
3. 서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안 된다.
ex) ([1+1)]

프로그램의 괄호검사 알고리즘은 다음과 같다.
왼쪽 괄호가 나오면 계속 스택에 쌓아둔다. 그러다가 오른쪽 괄호가 나오는 경우
스택에 쌓인 괄호와 짝을 맞춰서 짝이 맞는 경우 스택에서 제거해 나간다.
만약에 오른쪽 괄호가 나왔는데 스택상위에 있는 괄호와 맞지 않는 괄호라면 오류가
날 것이고, 문장이 다 끝났는데 스택에 요소가 남아있다면 그 역시 오류이다.

괄호검사를 만들어보자. 우선 괄호를 검사할 것이기 때문에 스택을 char타입으로 만들어준다.
문자열을 입력받고, 문자열의 길이를 구해서 0번부터 문자열 길이-1만큼 반복한다.
문자를 하나씩 가져와서 왼쪽 괄호가 나오면 스택에 넣는다.
오른쪽 괄호가 나오면 스택이 비었는지 먼저 확인하고 비어있다면 검사 실패를 반환한다.
스택이 있다면 하나를 빼서 같은 쌍이 아닌 경우 검사 실패를 반환한다.
만약 같은 쌍인 경우 for루프가 종료될 때까지 함수가 종료되지 않는다.
루프를 종료했고 스택에 어떤 값도 없다면 검사 성공이며 스택에 남아있다면 검사 실패다.

연산자는 우선순위를 갖기 때문에 수식도 스택을 사용해서 계산한다.
수식 표기 방법에는 "전위(prefix), 후위(postfix), 중위(infix)"가 있다.
연산자의 위치에 따라 연산자가 피연산자 사이에 있으면 중위,
연산자가 피연산자 뒤에 있으면 후위, 연산자가 피연산자 앞에 있으면 전위다.

일반적으로 사람들은 중위식 표기를 사용하지만, 컴파일러는 후위식 표기를 사용한다.
따라서 프로그래머가 중위식 프로그램을 작성하면 컴파일러는 후위식표기법으로 변환 후
이를 스택을 이용하여 계산한다. 후위를 선호하는 이유는 후위 표기방식은 
괄호를 생략할 수 있기 때문이다. 중위 표기를 할 경우 식을 끝까지 다 읽고 나서
우선순위를 파악해서 계산해야하지만, 후위 표기는 식 자체에 우선순위가 적용되어있어
왼쪽에서 오른쪽으로 수식을 읽으면서 계산만 해주면 된다.

먼저 후위 표기 수식을 계산하는 방법은 수식을 왼쪽에서 오른쪽으로 쭉 스캔하여
피연산자라면 스택에 저장하고 연산자라면 필요한 수 만큼의 피연산자를 스택에서 꺼내
연산을 실행한 뒤에 다시 스택에 그 수를 저장한다. 단, 피연산자가 쭉 이어져있는 
후위 표기법 특성상 12를 12인지 1과2인지 구분이 어렵기 때문에 ,로 구분한다.
후위 표기식의 결과를 구해보는 프로그램을 작성해보자. 
문자를 단순히 숫자로 바꾸는 과정은 -'0'을 취해주면 되기 때문에 어렵지 않지만
후위 표기 수식에  1자리 수 이상의 숫자가 들어간다면 문자열 숫자를 숫자로 바꿔주는
atoi함수를 써야할 것이고, 숫자가 커지기 때문에 구분을 해줄 수 있는 구분자로
,나 공백을 추가해야 할 것이다. 그렇게 된다면 ,또는 공백이 나오는 경우 
문자열만 증가 시키고 숫자가 나오는 경우에는 atoi로 구한다음 스택에 넣고 구분자나 연산자가
나올 때까지 주소위치를 증가시키는 방법을 사용해야 한다.
이렇게 후위표기 수식을 구하는 프로그램을 만들어봤다.

다음은 중위 표기 수식을 후위 표기 수식으로 변환하기 위한 방법이다.
중위 표기 수식을 왼쪽에서 오른쪽으로 스캔한다. 피연산자가 나오는 경우
후위 표기 수식에 출력을 바로 한다. 또는 후위 표기 수식이 저장되는 문자열 배열에 저장한다.
연산자가 나오는 경우에는 스택에 저장을 해둔다. 왜냐하면 후위 수식이므로 연산자들의 우선순위가
동일한 경우에는 가장 늦게 스캔된 연산자가 가장 먼저 출력되어야 하기 때문이다.
a+b*c => abc*+

하지만 우선순위가 다른 경우에는 우선순위가 높은 것이 먼저 출력되어야 하기 때문에
현재 스캔한 연산자와 스택의 연산자를 비교해서 스택에 있는 연산자가 우선순위가 더
높다면 스택에 있는 것을 출력 한 뒤에 스택에 쌓는다. 여기에서 우선순위가 높은 것은
연산자 자체적으로 높은 것도 있지만 동등한 우선순위일 경우 앞에 나온 숫자가 먼저
출력된다.
a stack:*
ab stack:* > scan: +
ab* stack: +
ab*c+ 
a*b+c => ab*c+

만약에 괄호가 들어가면 어떻게 처리해야 하는가? 우선 왼쪽 괄호는 연산자 중 우선순위가
가장 낮는 것으로 취급하기 때문에 그 이후에 나오는 어떤 연산자도 그대로 스택에 쌓인다.
이 후 오른쪽 괄호가 스캔 된다면 그대로 왼쪽 괄호가 pop될 때까지 연산자를 출력한다.
a stack: ( scan: +
ab stack: (+ scan: ) 오른쪽 괄호가 나왔으므로 왼쪽 괄호가 나올 때까지 스택 모두 pop
ab+ stack: * scan:c
ab+c stack: *
(a+b)*c => ab+c*

1. 중위수식을 왼쪽에서 오른쪽으로 반복해가며 1문자씩 비교한다.
2. 만약에 문자로 +,-,*,/ 연산자가 온다면 
우선적으로 스택에 연산자가 있는지 확인하고 없다면 스택에 push해준다. 
3. 만약에 스택에 연산자가 있다면 우선순위함수를 사용해서 우선순위를 비교해라 
4. 스택에 있는 연산자가 우선순위가 더 크거나 같다면 스택에 있는 것을 출력하고, 스캔한 문자를 스택에 쌓아라
5. '('왼쪽괄호가 나온다면 일단 스택에 쌓아라. 우선순위가 가장 낮기 때문에 스캔한 문자가
연산자라면 그 위에 계속 스택이 쌓인다.
6. ')'오른쪽괄호가 나온다면 왼쪽 괄호가 나올 때까지 연산자를 모두 출력한다. 마지막에 왼쪽괄호는 버린다.
7. 마지막으로 피연산자가 나온다면 이전의 숫자와 구분을 해주기 위해 이전 출력에
피연산자가 있었다면 ,를 출력해서 구분을 지어준다.
8. 그리고 피연산자가 2자리수 이상인 경우를 생각해서 숫자가 아닌 문자가 나올 때까지
반복해서 출력을 해준다.
9. 마지막으로 스캔이 완료되었다면 스택이 비어있는지 확인하고 남아있다면 모든 연산자를 pop해서 출력한다.

메모리 할당시 calloc함수를 쓰게되면 할당공간 값을 0으로 초기화해주는 같은 크기의 
메모리를 n개까지 할당할 수 있다.
(자료형)calloc(n,sizeof(자료형));

정리하면 이렇다.
후위수식을 계산할 때는 스택에 피연산자를 쌓아두고 연산자가 나올 때 피연산자를 꺼내서
계산하는 방식을 취하는 반면, 중위수식에서 후위수식으로 바꿀 때에는 연산자를 쌓아두고
피연산자가 나오고 나서 연산자를 출력하는 방식을 취한다. 연산자를 출력할 때도
우선순위가 있는 것이 먼저 계산해야하기 때문에 선출력되어야 하므로 연산자를 스택으로 갖는다.

마지막으로 미로의 출구찾기 문제도 스택으로 해결할 수 있다.
전지적인 시점이 아닌 1인 시점에서 미로를 벗어나려면 일단 가보는 수 밖에 없다.
일단 직진해서 분기가 나눠지는 분기점이 생기면 분기점을 스택에 쌓고 하나의 경로로 다시 가본다.
만약에 그 길에서 또 분기점이 생기면 다시 스택에 쌓는다. 이렇게 가다가 길이 없으면
다시 가까운 분기점으로 돌아가 다른 경로로 가본다. 이러한 작업을 반복하면 길을 찾을 수 있다.
최근에 저장된 분기점을 기록했다가 사용하는 것이므로 스택이 적합하다고 볼 수 있다.
또한 한 번 지나간 곳은 다시 가면 안되기 때문에 따로 기록을 해두어야 할 것이다.
모든 지점은 좌표 형태로 기록이 되며 값은 갈 수 있는 길인지(1 못가면 0), 방문했던 길인지(-1)를 표시한다.

이를 구현하는 알고리즘은 다음과 같다.
현 위치가 출구가 될 때까지 무한 반복한다.
현 위치를 가져오고 만약 현 위치에서 위,아래,오른쪽,왼쪽을 검색해서
갈 수 있는 길이고 아직 안 가본 길이라면 스택에 다음 좌표를 하나씩 할당한다.
그 다음 스택이 비어있는지 확인하고 비어있다면 더 이상 진행을 못하므로 실패
스택이 남아있다면 그곳으로 현 위치를 변경한다.