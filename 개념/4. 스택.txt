스택(stack): 아래에서 위로 쌓아두고 다시 위에서 아래로 빼는 형태의 자료구조.
컴퓨터에서 믿을 수 없을 정도로 많이 사용되는 자료구조로 주변에서도
스마트폰의 뒤로 가기를 누르면 현재 수행되는 앱이 종료되고 이전에 수행되던 앱이
다시 나타나는 구조도 스택형식으로 되어있다. 또 함수를 호출하게 되면 지역변수와
매개변수, 함수의 복귀주소등이 (운영체제의)시스템스택에 저장되어 함수가 종료되면 
운영체제에 반환한다. 

일상생활에서도 창고에 쌓여있는 상자를 생각해보자. 창고에서 새로운 상자를 쌓을 때는
제일 윗부분에 놓게된다. 상자가 필요하면 가장 윗부분부터 꺼내서 사용한다.
만약 중간부터 꺼내는 경우 상자가 붕괴될 것이다. 이러한 입출력 형태를 "후입선출"
나중에 들어온 것이 먼저 나간다는 의미를 갖는다.

따라서 입력과 출력은 스택의 최상단에서 이루어지기 때문에 스택 상단(stack top)이라고 하고
반대쪽인 하단부를 스택 하단(stack bottom)이라고 한다. 또 스택에 저장되는 것을 요소(element)라고
부른다. 스택에 요소가 하나도 없는 스택을 공백 스택(empty stack)이라고 부른다.

스택은 특히 자료의 출력순서가 입력순서의 거꾸로 되어야할 때 요긴하게 쓰인다.
예를 들면 A,B,C,D,E의 순서로 입력된 자료를 E,D,C,B,A처럼 출력할 때다.
또는 가장최근에 수행된 내역으로 돌아가는 되돌리기 기능도 있다.

스택의 ADT이다.
객체: 0개 이상의 원소를 가지는 유한 선형 리스트
연산{
    create(size): size크기의 empty stack을 생성함.
    is_full(stack) ::= 스택이 가득 차 있는지 판단.
        if(stack의 요소 수 == size) return TRUE;
        else return FALSE;
    is_empty(stack) ::= 스택이 비어있는지 판단.
        if(stack의 요소 수 == 0) return TRUE;
        else return FALSE;
    push(stack, item) ::= 스택에 특정 값을 추가함.
        if(is_full(stack)) return ERR_STACKFULL;
        else 스택의 맨 위에 값 추가.
    pop(stack) ::= 스택 맨 위에 있는 값을 제거 후 반환.
        if(is_empty(stack)) return ERR_STACKEMPTY;
        else 스택의 맨 위에 값을 제거 후 반환.
    peek(stack) ::= 스택의 가장 위에 있는 원소를 반환
        if(is_empty(stack)) return ERR_STACKEMPTY;
        else 스택의 맨 위에 있는 값 반환.
}

스택은 배열을 이용해서 구현할 수도 있고 연결리스트를 통해 구현할 수도 있다.
배열을 이용해서 구현할 경우 간단하고 성능이 우수한 반면 크기 설정되기 때문에 
크기가 제한된다는 단점이 있다. 연결리스트로 만든다면 구현이 복잡한 반면, 
크기를 필요에 따라 가변적으로 할 수 있다.
연결리스트는 나중에 학습하도록 하고 우선 배열을 이용한 스택을 만들어보자.

우선 stack top의 경우는 비어있을 경우 -1이라는 값을 갖는다. 
배열은 0부터 시작하기 때문이다.
이를 알고있다면 쉽게 배열로 구현할 수 있을 것이다. 

요소에 정수만 들어간다면 정수 배열스택, 문자가 들어간다면 문자 배열스택,
여러가지 요소들이 종합적으로 들어간다면 구조체 배열스택을 만들면 된다.

1. 전역변수와 배열,구조체를 이용한 방법
전역변수로 int top와 element stack[size] 스택배열,구조체를 생성한다.
그리고 각 스택은 함수를 통해 접근하는 방식이다. 단, 전역변수로 top과 스택을 생성하게 되면 
하나의 프로그램에 하나의 스택만 사용하게 되는 셈이다.

2. 여러개의 스택을 사용하기 위해서 객체지향의 개념을 사용하면 더 편리하지만 C의 경우는 
스택과 top을 하나의 구조체로 묶어 구조체 포인터를 함수의 매개변수로 사용해야한다.

typedef struct{
    int top;
    element stack[size];
}

다음과 같이 하나의 스택을 구현할 수 있는 멤버를 갖는 구조체를 만드는 것이다.
다만 스택의 크기는 항상 정해져있어 꽉차게된다면 스택을 줄여서 사용해야한다는 단점이 있다.

3. typedef struct{
    int top;
    int capacity
    element* stack;
}
따라서 다음과 같이 구조체 포인터로 선언한 후 동적할당을 사용하면 
스택의 크기를 미리 정해놓지 않고 스택이 꽉찰 때마다 capacity의 크기만큼 할당해서
사용할 수도 있다. 따라서 realloc()이라는 함수를 통해 메모리 공간을 다시 재할당해주는
연산과정도 필요하다. 사용방식은 malloc()과 동일하다.

스택의 응용: 괄호검사
프로그래밍 언어에서는 여러개의 괄호가 사용되는데 괄호의 짝이 일치해야 맞기 때문에
오류검사를 하는 프로그램을 만드는데 스택이 사용된다. 조건은 다음과 같다.
1. 왼쪽 괄호와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
3. 서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안 된다.
ex) ([1+1)]

프로그램의 괄호검사 알고리즘은 다음과 같다.
왼쪽 괄호가 나오면 계속 스택에 쌓아둔다. 그러다가 오른쪽 괄호가 나오는 경우
스택에 쌓인 괄호와 짝을 맞춰서 짝이 맞는 경우 스택에서 제거해 나간다.
만약에 오른쪽 괄호가 나왔는데 스택상위에 있는 괄호와 맞지 않는 괄호라면 오류가
날 것이고, 문장이 다 끝났는데 스택에 요소가 남아있다면 그 역시 오류이다.

괄호검사를 만들어보자.