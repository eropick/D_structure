스택은 최근에 들어온 자료가 먼저 나가는 후입선출의 구조를 가진다고 배웠다.
이와 반대로 큐(Queue)는 먼저 들어온 자료가 먼저 나가는 선입선출의 구조를 가진다.
Queue의 예로는 마트에서 줄과 같은 선착순, 마트 진열 품목도 같은 구조를 가진다.

큐는 뒤에 데이터가 하나씩 추가되고 앞에서는 데이터가 삭제되는 구조를 갖는다.
스택과 다른점이 다른 곳에서 삽입과 삭제가 일어난다는 점이다.
뒤에서 추가, 앞에서 삭제된다고 했는데 그래서 삽입이 일어나는 곳을
후단(rear), 삭제가 일어나는 곳을 전단(front)이라고 한다.

->삽입 후단(rear) d,c,b,a 전단(front) ->삭제

Queue의 ADT
객체: 0개 이상의 요소
연산{
    create(max_size) ::=
                최대 크기가 max_size인 공백큐 생성.
    init(q) ::=
                queue를 초기화 한다.
    is_empty(q) ::=
                if(size==0) return true;
                else return false;
    is_full(q) ::= 
                if(size==max_size) return ture;
                else return false;
    dequeue(q) ::=
                if( is_empty(q) ) queue_empty 오류;
                else q의 맨 앞을 읽고 요소를 제거하여 반환한다.
    enqueue(q,e) ::=
                if( is_full(q) ) queue_full 오류;
                else q의 맨 뒤에 요소를 추가한다.
    peek(q) ::=
                if( is_empty(q) ) queue_empty 오류;
                else q의 맨 앞에 요소를 반환한다.
}

스택에서는 삽입과 삭제에 관여할 때 모두 상단top한 곳에서 이루어지기 때문에
top 하나만 사용했지만 큐에서는 삭제에 관여할 때는 front, 삽입에 관여할 때는
rear라는 두 개의 변수를 사용한다. 큐는 마찬가지로 프로그래머의 도구로서
널리 쓰이는데 특히 일상생활에서 일어나는 일들을 시뮬레이션 한다던지
운영체제는 물론 컴퓨터와 다른 주변기기 사이의 연결에서도 흔히 사용된다. 
예를들면 프로세스 간의 처리속도가 빠른 쪽이 미리미리 데이터를 조금씩 보내놓아서
먼저 보낸 데이터가 먼저 들어오도록 하는 방식으로 효율적으로 데이터를 보낼 수 있다.
스택과 마찬가지로 배열과 연결 리스트를 이용하여 구현할 수 있다.

먼저 1차원 배열을 이용해서 간단한 queue를 만들 수 있다.
queue를 특정한 크기의 배열로 생성한 뒤, 삽입과 삭제에 관여하는
front와 rear변수를 생성한다. front는 항상 queue의 첫 번째 요소를
가리켜야 하고 rear는 마지막요소를 가리켜야 한다.
front와 rear의 초기값은 -1로 요소가 삽입되면 rear의 값을 1증가시키고
그 곳에 삽입한다. 삭제를 할 때에도 front를 1증가시키고 그 자리에 있는 값을 삭제한다.
이와 같이 1자 직선 형태의 queue를 선형큐라고 한다.
C언어를 통해 선형queue를 간단하게 구현해보자.

선형큐는 이해하기에는 쉽지만 문제점이 있다.
front와 rear의 값이 계속 증가만 하기 때문에 언젠가는 배열의 끝부분에 도달하게 되고
배열의 앞부분이 비어도 재사용을 할 수 없다는 점이 가장 문제다.
이를 해결할 수 있는 방법 중 하나는 front와 rear를 비어있는 공간만틈 왼쪽으로 이동시키는 것인데
매번 이동시키려면 상당한 시간과 코딩 또한 복잡해지다는 점이 있다.
하지만 원형으로 쉽게 생각을 해보자. rear의 max_size-1에 도달하게 되면 
다음 증가 값은 0으로 초기화 되어 원형으로 돌아가는 형태이다. 이를 원형큐라고 한다.

원형큐의 방식은 개념이 조금 변형되는데 front와 rear가 -1이 아닌 0부터 시작이 된다. 원형이기 때문에
-1을 가리키는 것을 제외하게 되고 나머지는 동일하게 생각하면 된다. 
front는 첫 번째 요소의 한단계 앞을, rear는 마지막 요소를 가리킨다.
rear의 값이 1증가하고 데이터가 삽입되며, front의 값이 1증가하고 요소를 삭제반환한다.
하지만 원형의 방식을 띄고 있어서 가장 중요한 개념이 있는데
선형에서 front와 rear가 같은 곳을 가리키면 공백인데
원형에서는 재사용이 가능하기 때문에 모든 요소가 채워져도 두 개가 가리키는 곳이 같다.
따라서 원형에서는 한 요소를 비워둔 상태를 포화상태로 처리해야 한다.
만약에 추가적으로 요소들의 개수를 저장해둔 count변수를 추가해서 사용한다면
포화상태와 공백상태를 구분할 수 있으므로 한 요소를 비워두지 않아도 된다.
원형으로 사이클을 돌리기 위한 알고리즘으로 최대요소 크기로 나눈 나머지를 반환하는 
방법이 있고, 최대요소가 되는 다음에는 0으로 값을 바꿔주는 방법이 있다.
스택이나 큐에서 삭제라는 개념은 단순히 요소가 가리키는 위치를 변경해주고 반환하는 형태이다.
메모리를 직접 삭제할 수 없으니 스택이 가리키는 요소들, 큐가 가리키는 요소들의 값만을 구한다.
원형큐를 구현해보자.

다음은 이러한 원형큐를 직접적으로 어떤 문제에 활용하느냐이다.
buffer라는 데이터간의 상호작용을 할 때 일시적인 메모리공간(통로)이 있다.
생산자 - 소비자 프로세스: 큐형태를 버퍼로 사용한다.
교통관리시스템: 컴퓨터로 제어되는 신호등에서는 신호등을 순차적으로 제어한다.
cpu 스케줄링: 실행 가능한 프로세스들을 저장하거나 이벤트를 기다리는 프로세스를
큐형태로 저장해둔다.

생산자 - 소비자 프로세스의 일환으로 20%의 확률로 큐에 생산(삽입)을 하고
10%의 확률로 소비(삭제반환)하는 프로그램을 만들어보자.
반복은 100번의 시행으로 한다.

덱(deque): double-ended queue
큐의 front와 rear 모두 삽입과 삭제가 가능한 큐이다.
스택과 큐를 합쳐놓은 개념이며 한 쪽에서만 삽입과 삭제를 한다면 스택처럼 사용할 수도 있다.
하지만 중간에 삽입과 삭제를 하는 것은 허용하지 않는다.

덱 ADT
객체: n개의 element형 요소
연산 {
    create() ::=
            덱 생성
    init(dq) ::=
            덱 초기화
    is_empty(dq) ::=
            덱이 공백상태인지 확인
    is_full(dq) ::=
            덱이 가득차 있는지 확인
    add_front(dq,e) ::=
            덱의 전단에 요소 e를 삽입
    add_rear(dq,e) ::=
            덱의 후단의 요소 e를 삽입
    delete_front(dq) ::=
            덱의 전단에 요소를 삭제반환
    delete_rear(dq) ::=
            덱의 후단에 요소를 삭제반환
    get_front(dq) ::=
            덱의 전단에 요소 반환
    get_rear(dq) ::=
            덱의 후단에 요소 반환       
}

원형큐와 덱은 공통점이 많은데 원형큐를 확장하면 덱을 쉽게 구현할 수 있다.
원형큐에서 사용하는 연산은 그대로 사용할 수 있으며, get_rear, delete_rear, add_front만 구현한다.
덱도 연결리스트로 구현할 수도 있지만 연결된 스택이나 큐에 비해서 훨씬 복잡하다.
이중 연결리스트에서는 선행노드와 후속노드를 가리키는 포인터 변수를 가져야 하는데
전단과 후단에 모두 삽입,삭제가 가능한 덱에서는 알아야 할 정보를 더 넣어주어야 하기 때문이다.

큐의 응용: 시뮬레이션
큐는 주로 컴퓨터큐잉이론에 따라 시스템의 특성을 시뮬레이션하여 분석하는데 이용된다.
보통 고객에 대한 서비스를 수행하는 서버와 서비스를 받는 클라이언트로 구성되어있는데
제한된 수의 서버로 인해 클라이언트는 대기 행렬에서 기다린다. 이 대기행렬이 queue로 구성된다.
클라이언트가 들어와서 어떤 서비스를 받고 나가는 것을 시뮬레이션 해보자.
서비스를 제공하는 사람은 1명으로 가정하고 대기행렬을 queue로 구현
주어진 시간(반복루프)동안 고객이 랜덤한 간격으로 들어온다.
서비스 시간도 특정 값 안에서 랜덤하게 이루어진다. 
한 고객의 서비스가 종료되면 다음 고객이 서비스를 받는다.
고객들의 평균 대기시간을 계산한다.

반복루프에서
1. minute = 60분으로 한다. (1시간)
2. clock을 증가 요소로 한다.
3. [0,10사이의 난수를 생성 후 3보다 작으면 새로운 고객 입장]
4. 새로운 고객이 들어오는 경우{
    고객의 id, 도착시간, 서비스 시간(랜덤)을 처리해서 큐에 넣는다.
}
5. 서비스 받고있는 사람이 있는지 확인한 후 있으면 서비스 시간을 감소시킨다.
6. 서비스 받고있는 사람이 없다면 큐에 대기하는 고객을 넣는다.{
    이때 현재 시간-도착 시간 계산하여 총 대기시간을 계산한다.
}
7. 60분의 시간이 지나는 경우 고객들이 기다린 시간을 합하여 출력하고
총 대기시간을 인원수로 나눠 평균 대기시간을 계산한다.