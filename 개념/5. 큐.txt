스택은 최근에 들어온 자료가 먼저 나가는 후입선출의 구조를 가진다고 배웠다.
이와 반대로 큐(Queue)는 먼저 들어온 자료가 먼저 나가는 선입선출의 구조를 가진다.
Queue의 예로는 마트에서 줄과 같은 선착순, 마트 진열 품목도 같은 구조를 가진다.

큐는 뒤에 데이터가 하나씩 추가되고 앞에서는 데이터가 삭제되는 구조를 갖는다.
스택과 다른점이 다른 곳에서 삽입과 삭제가 일어난다는 점이다.
뒤에서 추가, 앞에서 삭제된다고 했는데 그래서 삽입이 일어나는 곳을
후단(rear), 삭제가 일어나는 곳을 전단(front)이라고 한다.

->삽입 후단(rear) d,c,b,a 전단(front) ->삭제

Queue의 ADT
객체: 0개 이상의 요소
연산{
    create(max_size) ::=
                최대 크기가 max_size인 공백큐 생성.
    init(q) ::=
                queue를 초기화 한다.
    is_empty(q) ::=
                if(size==0) return true;
                else return false;
    is_full(q) ::= 
                if(size==max_size) return ture;
                else return false;
    dequeue(q) ::=
                if( is_empty(q) ) queue_empty 오류;
                else q의 맨 앞을 읽고 요소를 제거하여 반환한다.
    enqueue(q,e) ::=
                if( is_full(q) ) queue_full 오류;
                else q의 맨 뒤에 요소를 추가한다.
    peek(q) ::=
                if( is_empty(q) ) queue_empty 오류;
                else q의 맨 앞에 요소를 반환한다.
}

스택에서는 삽입과 삭제에 관여할 때 모두 상단top한 곳에서 이루어지기 때문에
top 하나만 사용했지만 큐에서는 삭제에 관여할 때는 front, 삽입에 관여할 때는
rear라는 두 개의 변수를 사용한다. 큐는 마찬가지로 프로그래머의 도구로서
널리 쓰이는데 특히 일상생활에서 일어나는 일들을 시뮬레이션 한다던지
운영체제는 물론 컴퓨터와 다른 주변기기 사이의 연결에서도 흔히 사용된다. 
예를들면 프로세스 간의 처리속도가 빠른 쪽이 미리미리 데이터를 조금씩 보내놓아서
먼저 보낸 데이터가 먼저 들어오도록 하는 방식으로 효율적으로 데이터를 보낼 수 있다.
스택과 마찬가지로 배열과 연결 리스트를 이용하여 구현할 수 있다.

먼저 1차원 배열을 이용해서 간단한 queue를 만들 수 있다.
queue를 특정한 크기의 배열로 생성한 뒤, 삽입과 삭제에 관여하는
front와 rear변수를 생성한다. front는 항상 queue의 첫 번째 요소를
가리켜야 하고 rear는 마지막요소를 가리켜야 한다.
front와 rear의 초기값은 -1로 요소가 삽입되면 rear의 값을 1증가시키고
그 곳에 삽입한다. 삭제를 할 때에도 front를 1증가시키고 그 자리에 있는 값을 삭제한다.
이와 같이 1자 직선 형태의 queue를 선형큐라고 한다.
C언어를 통해 선형queue를 간단하게 구현해보자.

선형큐는 이해하기에는 쉽지만 문제점이 있다.
front와 rear의 값이 계속 증가만 하기 때문에 언젠가는 배열의 끝부분에 도달하게 되고
배열의 앞부분이 비어도 재사용을 할 수 없다는 점이 가장 문제다.
이를 해결할 수 있는 방법 중 하나는 front와 rear를 비어있는 공간만틈 왼쪽으로 이동시키는 것인데
매번 이동시키려면 상당한 시간과 코딩 또한 복잡해지다는 점이 있다.
하지만 원형으로 쉽게 생각을 해보자. rear의 max_size-1에 도달하게 되면 
다음 증가 값은 0으로 초기화 되어 원형으로 돌아가는 형태이다. 이를 원형큐라고 한다.

원형큐의 방식은 개념이 조금 변형되는데 front와 rear가 -1이 아닌 0부터 시작이 된다. 원형이기 때문에
-1을 가리키는 것을 제외하게 되고 나머지는 동일하게 생각하면 된다. 
front는 첫 번째 요소의 한단계 앞을, rear는 마지막 요소를 가리킨다.
rear의 값이 1증가하고 데이터가 삽입되며, front의 값이 1증가하고 요소를 삭제반환한다.
하지만 원형의 방식을 띄고 있어서 가장 중요한 개념이 있는데
선형에서 front와 rear가 같은 곳을 가리키면 공백인데
원형에서는 재사용이 가능하기 때문에 모든 요소가 채워져도 두 개가 가리키는 곳이 같다.
따라서 원형에서는 한 요소를 비워둔 상태를 포화상태로 처리해야 한다.
만약에 추가적으로 요소들의 개수를 저장해둔 count변수를 추가해서 사용한다면
포화상태와 공백상태를 구분할 수 있으므로 한 요소를 비워두지 않아도 된다.
원형으로 사이클을 돌리기 위한 알고리즘으로 최대요소 크기로 나눈 나머지를 반환하는 
방법이 있고, 최대요소가 되는 다음에는 0으로 값을 바꿔주는 방법이 있다.
스택이나 큐에서 삭제라는 개념은 단순히 요소가 가리키는 위치를 변경해주고 반환하는 형태이다.
메모리를 직접 삭제할 수 없으니 스택이 가리키는 요소들, 큐가 가리키는 요소들의 값만을 구한다.
원형큐를 구현해보자.

다음은 이러한 원형큐를 직접적으로 어떤 문제에 활용하느냐이다.
buffer라는 데이터간의 상호작용을 할 때 일시적인 메모리공간(통로)이 있다.
생산자 - 소비자 프로세스: 큐형태를 버퍼로 사용한다.
교통관리시스템: 컴퓨터로 제어되는 신호등에서는 신호등을 순차적으로 제어한다.
cpu 스케줄링: 실행 가능한 프로세스들을 저장하거나 이벤트를 기다리는 프로세스를
큐형태로 저장해둔다.

생산자 - 소비자 프로세스의 일환으로 20%의 확률로 큐에 생산(삽입)을 하고
10%의 확률로 소비(삭제반환)하는 프로그램을 만들어보자.
반복은 100번의 시행으로 한다.