요즘의 컴퓨터는 예전의 컴퓨터와 비교해서 엄청난 계산속도와 방대한 메모리를 가진다.
또한 계속해서 발전하는 추세이다. 하지만 과거에 비해서 프로그램의 규모가 커지고 있기 때문에
처리해야할 연산의 양 또한 커진다. 따라서 프로그램 작성 시 계산시간을 줄이고
메모리를 효과적으로 사용할 필요성이 있다.

알고리즘간의 효율성은 적은 자료양의 입력이라면 무시해도 되지만 많은 자료양의 입력이면
그 차이는 상당할 수 있다.

동일한 작업을 하는 두 프로그램이 있다고 할 때 입력 자료 개수에 따라 수행시간이 달라질텐데
A프로그램의 계산시간은 입력 자료의 제곱에 해당하는 시간이고
B프로그램의 계산시간은 입력 자료의 2의 n승에 해당하는 시간이다.

만약 입력자료가 6일 경우 A프로그램은 36초, B프로그램은 2^6 = 64초가 걸리는 것으로 몇 초 차이겠지만
입력자료가 100일 경우 A프로그램은 100000초, B프로그램은 2^100 로 시간이 엄청 늘어난다.
대부분의 사용자들은 더 빠른 프로그램을 선호한다. 따라서 프로그램의 속도가 느리다면 경쟁에서 밀릴 수 밖에 없다.

수행시간을 계산하는 방법은 C에서 다음과 같은 방법으로 알 수 있다.

#include<time.h>

time_t start,stop; //시간 값을 받는 자료형
double duration;

start = time(NULL); //첫 시간을 잰다.

실행코드

stop = time(NULL); //끝난 뒤에 시간을 잰다.
duration = (double) difftime(stop,start);
//duration의 값이 차이가 된다. 

그러나 이렇게 하게 된다면 알고리즘이 비교적 단순한 경우 쉽게 구현할 수 있지만
복잡한 경우에는 우선 구현부터 한 뒤에 시간을 확인할 수 있기 때문이다.
또 동일한 하드웨어 환경에서 비교를 해야 하며 컴퓨터 언어에 따라서도 시간이 달라진다.
즉, 실험되지 않은 입력에 대해서는 수행시간을 주장할 수 없다.

이와 같은 문제점 때문에 알고리즘을 구현하지 않고서도 알고리즘의 효율성을 따져보는 기법이 
생겼는데 "알고리즘 복잡도 분석" 이다. 구현하지 않고도 모든 입력을 고려하는 방법이며
하드웨어와 소프트웨어 환경과는 관계없잉 효율성을 평가할 수 있다.

알고리즘 복잡도를 분석하기 위해 2가지 측면으로 고려할 수 있는데
알고리즘의 수행시간과 알고리즘이 필요로하는 메모리의 양이다.

수행시간 분석을 시간 복잡도(time complexity)라고 하며 알고리즘이 사용하는 기억공간 분석을
공간 복잡도(space complexity)라고 한다. 보통 우리가 알고리즘의 복잡도를 이야기할 때는 
시간 복잡도를 이야기 한다. 시간 복잡도는 알고리즘의 절대적인 수행시간이 아닌 알고리즘을
이루고 있는 연산들이 몇 번이나 수행되는지를 숫자로 표시한다.
이러한 연산에는 곱,덧셈과 같은 산술연산과 대입, 비교, 이동 연산도 있다.

만약 동일한 조건에서 알고리즘1이 20개 연산, 알고리즘2가 100개 연산을 한다고 해보자.
알고리즘1이 연산이 더 적으므로 더 효육적인 알고리즘이라고 할 수 있다.
이것이 시간복잡도 방법의 기본 개념이지만.. 연산들의 수행횟수는 상수가 아니라 변수다.
수행횟수는 입력개수n에 따라 변하게 된다. 입력이 10일 때와 1000일 때 연산의 개수는
큰 차이가 있다. 따라서 연산의 수를 입력의 개수 n의 함수로 나타낸 것을 
시간 복잡도 함수라고 하며 T(n)이라고 표기한다.