복잡한 자료구조를 구현하는데에는 포인터는 필수적이다.
포인터(pointer)는 다른 변수의 주소 값을 할당받는 '변수'이다.
주소값이외의 값을 받으려고하면 오류가 나게 된다.

모든 변수에는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져있다.
포인터변수는 보통 정확한 숫자보다 화살표로 그려진다.

C에서는 포인터와 관련된 주요 연산 2가지가 있다.
&연산자(주소연산자)
*연산자(간접참조,역참조연산자)

&연산자는 해당 변수의 주소를 반환하며
*연산자는 해당 객체를 참조한다. 간접적으로 값에 접근할 수 있으며
이를 통해 값을 수정한 경우 그대로 수정이 반영된다.

이 때문에 함수에 매개변수를 포인터로 받게 되면 함수의 값을 반환하지 않아도
값에 접근이 가능하여 함수로 수정을 할 수 있게 된다. 

또한 이러한 포인터변수도 주소를 갖을 것이다. 그러면 포인터 변수의 주소를 받는 
포인터도 있어야 할 것이다. **p와 같이 표현한다.

배열과 포인터의 관계
함수의 매개변수로 배열이 전달되는 경우에는 함수 안에서 배열의 내용을 변경할 수 있다.
그 이유가 바로 배열의 이름이 배열의 시작위치를 가리키는 포인터로 사용되기 때문이다.
실제로 컴파일러가 배열의 이름에 공간을 할당하지 않고 이름이 있는 곳의 배열의 첫 번째
요소의 주소로 대치하는 것이다. 배열의 이름이 포인터이기 때문에 함수의 매개변수로 전달될 때에는
포인터가 전달되게 되는 것이다. 이는 메모리 공간과 함수 호출 시간을 절약하는 기법이다.
함수 호출 시에 배열을 복사하지 않아도 사용할 수 있다.

널포인터: 어떠한 객체도 가르키지 않는 포인터다.
C에서 널 포인터는 NULL이라는 매크로로 표시한다.
포인터를 사용하기전에는 반드시 그 포인터가 널 포인터인지 확인해야한다.

if(p==NULL){
    fprintf(stderr,"오류: 포인터가 아무 것도 가르키지 않습니다.");
}

포인터가 아무것도 가르키고 있지 않을 때에는 항상 NULL로 만들어놓는 것이 중요한데
널포인터를 가지고 역참조하게되면 시스템에서 오류가 발생해서 알기 쉽다.
잘못된 포인터를 가지고 메모리를 변경하는 것보다 오류가 발생하게하는 것이 낫다.

배열말고도 구조체에 대해서 포인터를 선언해서 멤버에 접근할 수 있다.
구조체 포인터를 통해 멤버에 접근할 때는 (*ps). 역참조를 한 뒤.연산으로 접근하는 것보다
->연산으로 접근하는 것이 보기에 더 직관적이고 편리하다.
자료구조에서는 구조체에 대한 포인터도 함수의 매개변수로 자주 전달된다.

동적 메모리 할당(dynamic memory allocation)
일반적으로 배열은 크기가 고정(혹은 정적)되어있다. 배열은 선언을 할 때 SIZE를 정해서 선언을 하기 때문이다.
이 고정된 크기 때문에 많은 문제가 발생하게 되는데 바로 프로그램을 작성할 당시 얼마나 많은
입력이 있는지 예상이 불가능하기 때문이다. 처리가능한 메모리 공간보다 많은 입력이 있을 경우
처리를 못하게 되고 적은 입력이 있다면 메모리 공간의 낭비로 이어진다.
이 때문에 필요한 만큼의 메모리를 할당받아서 사용하고 끝나면 시스템에 메모리를 반납하는 기능이 있다.
이것을 동적 메모리 할당이라고 한다.

동적 메모리가 할당되는 공간을 heap(히프)라고 하며 이 공간은 운영체제가 
사용하지않는 메모리를 모아두는 곳이다. 필요한 만큼 할당받고 필요할 때에 
반납하기 때문에 효율적으로 사용가능하다. 
C에서 사용하는 동적할당의 방식이다. 

int *p;
p = (int*)malloc(sizeof(int));
*p = 1000;
free(p);

malloc함수는 sizeof 바이트 만큼의 메모리 블록을 할당하는데 sizeof함수는 
특정 변수나 자료형의 크기만큼을 바이트 숫자로 반환한다. 반환되는 자료의 타입이 void *이므로
(int*)로 해당 포인터의 자료형에 맞게 형변환을 해준다. 만약 메모리 확보가 불가능하면 NULL을 반환한다.
따라서 반환값이 NULL인지 항상 결과를 확인할 필요가 있다.
free함수는 할당된 메모리 블록을 운영체제에 반환한다. 단, malloc함수가 반환했던 포인터값인 p를
잊어버리게되면 동적 메모리를 반환할 수 없다.
malloc과 free함수는 stdlib.h헤더에 있다.

C에서는 이러한 동적배열의 개념으로 인해 특정 변수를 배열의 크기로 
지정하여 선언하는 것이 문법에서 오류가 있다고 판단한다.
따라서 배열의 크기를 정하고 싶다면 동적배열 만들어서 사용한다.
(int*)malloc(sizeof(int)*size);
size는 int형 배열의 크기

구조체도 포인터를 갖을 수 있기 때문에 동일하게 동적할당을 할 수 있다.
하지만 이렇게 동적으로 생성된 구조체는 포인터를 통해서만 접근이 가능하다.