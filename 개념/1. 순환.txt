순환(recursion)재귀
어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법.
본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다.
여담으로 현대적인 언어는 순환을 지원하지만 포트란이나 코볼같은 고전언어는 순환이 불가능하다.

ex) 팩토리얼
자기자신에서 -1을 한 값을 1이 될 때까지 계속해서 곱해가는 계산방식

factorial(n)
{
    1 (n=0)
    n*factorial(n-1) (n>=1)
}
//n이 1과 같거나 보다 클 경우 자기 자신과 자기자신에서 -1한 factorial값을 곱한다.

이러한 함수 호출의 과정은 다른 함수를 호출할 때와 다르지 않다.
예를들어 n의 값이 3으로 시작을 한다고 해보자.

factorial(3)이라는 함수를 호출해서 활성 레코드(매개변수,리턴값,지역변수,복귀 주소)가 
시스템 스택에 저장되고 매개변수와 지역변수를 스택으로 부터 할당받는다.
이 후 연산을 통해 factorial(2)함수가 호출되고 시스템 스택에 저장된다.
연산을 하다보면 factorial(1)함수가 호출되고 스택에 저장되며
factorial(0)함수가 호출되고 연산을 한 뒤 함수가 종료되면
스택에서 복귀주소를 추출하여 호출한 함수로 되돌아간다. 
그러면 factorial(0)이 종료되고 factorial(1)로 
factorial(1)이 종료되고 factorial(2)로
factorial(2)가 종료되고 맨처음 factorial(3) 순서대로 함수가 종료된다.
이처럼 순환에 있어서 컴퓨터는 스택으로 함수를 관리한다는 것을 알 수 있다.

순환 알고리즘은 n*factorial(n-1) (n>=1)과 같이 자기자신을 순환적으로 호출하는 부분과
1 (n=0)처럼 순환을 멈추는 부분으로 구성되어 있다. 만약 순환을 멈추는 부분이 없다면
무한 순환 호출을 실행하게 되고 결국 오류로 인해 프로그램이 멈추게 된다.

반복의 기능은 컴퓨터 알고리즘의 주요 특징인데 이것을 빠르게 되풀이 하는 것이 주요 능력이다.
for과 while문처럼 반복구조로 되풀이하는 방법과 재귀함수처럼 순환을 시키는 방법이 있는데
반복을 하게 되면 지나치게 복잡해지는 경우가 있어 순환이 좋은 해결방법이 될 수도 있다.
하지만 일반적으로 순환은 함수를 호출하는 것이기 때문에 반복보다 수행속도는 떨어진다.
그래서 많은 경우 순환은 반복으로 변경할 수 있다. 팩토리얼의 경우 반복이 더 빠르다.

순환과 반복중에 어떤 형태가 바람직할까에 대한 답은 문제정의가 순환적으로 되어 있는 경우만
순환으로 사용하는 것이다. 또 순환형태의 코드가 간결해서 이해하기도 편하다.
그렇지만 순환의 약점은 실행 시간에 있다. 적지않게 순환을 사용하지 않으면 
프로그램을 작성하기 어려운 경우가 존재하기 때문에 익혀두어야 한다.

순환의 원리를 보면 문제를 해결하지 않고 단순히 순환호출만 하는 것이 아니라 일부 문제를 해결한 후
나머지 문제에 대해 순환호출을 한다는 것이다. 보통 어떤 작업을 할 때 한 사람이 다하면 시간이 걸리기 
때문에 분야별로 전문가를 고용해서 일부를 한 뒤에 또 다른 전문가가 일부를 하고 이런식으로 이루어 진다.
따라서 문제가 진행될수록 문제의 크기는 작아져야 하는 특징이 있다.

순환을 사용하는 작업은 정의가 순환적으로 되어 있는 경우에 유리하다.
팩토리얼, 피보나치, 이항계수, 이진 트리 알고리즘, 이진 탐색, 하노이탑 등이 있다.

1. 거듭제곱을 계산하는 프로그램을 작성해보면 반복으로 하는 경우 n번의 반복 곱연산과
n번의 대입 연산이 필요하므로 O(n)이 되는 반면, 순환으로 계산하는 경우 문제 크기가
한 번 호출할 때마다 절반씩 줄어들기 때문에 O(log2 n)이 되어 순환이 더 빠르다.

2. 피보나치 수열
피보나치 수열은 앞의 두 숫자를 더해 뒤에 숫자를 만들어나가는 방식이다.
기본 값은 0 다음은 1로 시작해서 3번째 값부터 앞의 두 숫자를 더해 나간다.
이를 순환으로 구해보면 단순하게 구할 수 있지만 시행횟수가 올라갈수록
함수를 여러번 호출하게 되어 비효율적이 된다. 한 번 호출마다 두 번의 호출이 이어지므로
시간복잡도는 O(2^n)이 되어버린다.

3. 하노이탑
하나의 크기가 큰 순서대로 쌓여있는 원판탑이 있고 막대가 2개가 더 있다.
이 원판탑에서 원판을 한 번에 하나씩 옮겨서 다른 곳에 원판탑을 만든다고 한다.
단, 맨 위에 있는 원판만 이동할 수 있으며 크기가 작은 원판위에 큰 원판이 쌓일 수는 없다.

A,B,C 탑에서 기본적으로 원판이 1개일 때는 A에서 C로 넘기는 간단한 작업에서 출발한다.
원판이 n(n>1)일 경우 맨 밑의 원판을 제외한 모든 원판(n-1)을 B로 넘기는 작업 수행 후,
남은 1개의 원판을 C로 옮기고, 마지막으로 B에 있던 원판을 C로 옮기는 작업을 해주는 것이다.

이 문제는 결국 가장 아래에 있는 원판을 다른 쪽으로 넘겨야하는 문제이다.
즉, 기둥A,B,C가 있고 A에 있는 원판을 C로 옮긴다고 하면
원판이 n개 있을 때 가장아래에 있는 원판 1개를 제외한 n-1개의 원판을
B로 옮긴뒤 A의 가장아래 원판을 C로 옮기고 B에 있는 n-1개의 원판을 다시 C로 옮기는 방법의 반복이다.

간단한 3개의 원판으로 생각해보자. 제일위에 있는 원판 순서대로 1,2,3이라고 하자
원판1을 A에서 C로 옮긴다. 2 // 0 // 1
원판2를 A에서 B로 옮긴다. 1 // 1 // 1
원판1을 C에서 B로 옮긴다. 1 // 2 // 0
원판3을 A에서 C로 옮긴다. 0 // 2 // 1
원판1을 B에서 A로 옮긴다. 1 // 1 // 1
원판2를 B에서 C로 옮긴다. 1 // 0 // 2
원판1을 A에서 C로 옮긴다. 0 // 0 // 3

순환 함수로 표현하면
int hanoi(int n,char from, char tmp, char to)
{
    if(n==1) printf("원판1이 %c에서 %c로 이동했습니다.\n",n,from,to);
    //어떻게 되었든 마지막에 이동하는것은 제일 위에있는 원판1일 수 밖에 없음.
    else{
        //n이 2이상이면 먼저 n-1을 tmp로 이동시켜야 한다.
        hanoi(n-1,from,to,tmp);
        //다음은 마지막에 있는 원판을 to로 이동시키는 것이다.
        printf("원판%d이(가) %c에서 %c로 이동했습니다.\n",n,from,to);
        //마지막으로 n-1의 tmp에 있던 원판을 to로 이동시킨다.
        hanoi(n-1,tmp,from,to);
    }
}
hanoi(4,'A','B','C'); 가 된다.

n-1을 옮기는 방법은 이걸 다시 순환 호출하면 나온다. 

이처럼 하노이 탑의 경우는 반복으로 쉽게 해결하기가 어려운데 그 이유는
순환 호출이 함수의 맨 끝에서 이루어지는 꼬리 호출이 아닌 여러군데에서 
순환 호출이 이루어지는 머리 호출로 이루어져있기 때문이다. 

물론 이를 반복으로 못하는 것은 아니다. 하노이탑의 형태는 스택의 형식을 띄고 있어
맨위에서부터 하나씩 가져오는 형태이다. 명시적으로 스택을 만들어 준 뒤 반복해주면 된다.